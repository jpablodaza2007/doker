ğŸ§© Parte 1 â€“ AnÃ¡lisis conceptual (ArtÃ­culo de Devart)
1. Problema principal que resuelve la normalizaciÃ³n y su importancia en sistemas empresariales

La normalizaciÃ³n busca eliminar la redundancia de datos (repeticiÃ³n innecesaria de informaciÃ³n) y 
evitar las anomalÃ­as en las operaciones de inserciÃ³n, actualizaciÃ³n y eliminaciÃ³n.

En sistemas empresariales, esto es crÃ­tico porque:

Garantiza la coherencia e integridad de los datos en mÃºltiples procesos (ventas, clientes, inventarios, etc.).

Facilita el mantenimiento y escalabilidad del sistema, al reducir inconsistencias.

Mejora la calidad de la informaciÃ³n, lo que impacta directamente en la toma de decisiones y en la confianza en los datos.

2. Diferencias entre 1NF, 2NF y 3NF

SegÃºn los ejemplos tÃ­picos (como los de Devart):

Primera Forma Normal (1NF):

Elimina los valores repetidos o agrupados dentro de una misma columna.

Cada campo debe tener solo un valor atÃ³mico.

Ejemplo: una columna llamada â€œTelÃ©fonosâ€ con varios nÃºmeros separados por comas viola la 1NF; se corrige 
creando una tabla donde cada telÃ©fono tenga su propio registro.

Segunda Forma Normal (2NF):

Se aplica a tablas que ya estÃ¡n en 1NF.

Elimina las dependencias parciales, es decir, cuando una columna depende solo de una parte de una clave compuesta.

Ejemplo: si una tabla de â€œPedidosâ€ tiene clave compuesta (ID_Pedido, ID_Producto) y el campo â€œNombre_Productoâ€ 
depende solo de ID_Producto, se separa en otra tabla â€œProductosâ€.

Tercera Forma Normal (3NF):

Se aplica a tablas en 2NF.

Elimina las dependencias transitivas, donde un atributo no clave depende de otro atributo no clave.

Ejemplo: si â€œID_Clienteâ€ determina â€œCiudadâ€ y â€œCiudadâ€ determina â€œCÃ³digo Postalâ€, se separa la tabla de ciudades 
para evitar redundancia.

3. Ejemplo donde la normalizaciÃ³n mejora la integridad pero afecta el rendimiento

En los ejemplos de Devart, cuando los datos de clientes, pedidos y productos se separan en distintas tablas (para cumplir 3NF), se mejora la integridad referencial:

No se repiten nombres de clientes o precios de productos en cada pedido.

Los cambios en una tabla (por ejemplo, el nombre de un cliente) se reflejan en toda la base.

Sin embargo, esta separaciÃ³n implica que para obtener informaciÃ³n consolidada (como un informe de ventas completo) se deban hacer mÃºltiples uniones (JOINs) entre tablas.

Esto puede afectar el rendimiento en bases de datos grandes, ya que cada JOIN aumenta el tiempo de respuesta y el consumo de recursos.

4. Papel de las dependencias funcionales y cÃ³mo identificarlas

Las dependencias funcionales indican cÃ³mo un atributo determina a otro dentro de una tabla.
Por ejemplo, si en una tabla de empleados el ID_Empleado determina el Nombre, Cargo y Salario, se expresa como:
ID_Empleado â†’ Nombre, Cargo, Salario.

Su papel en la normalizaciÃ³n es detectar relaciones lÃ³gicas entre columnas para decidir quÃ© atributos deben separarse en otras tablas.
Para identificarlas:

Analizas las reglas del negocio (quÃ© datos dependen de cuÃ¡les).

Buscas columnas que se repiten con los mismos valores de otra (indicando dependencia).

Compruebas si un atributo puede predecir el valor de otro sin ambigÃ¼edad.

5. CuÃ¡ndo es justificable desnormalizar una base de datos

La desnormalizaciÃ³n se justifica cuando las exigencias de rendimiento y velocidad de consulta superan la necesidad de mantener el modelo perfectamente normalizado.
Ejemplos de contexto:

Sistemas de reportes o anÃ¡lisis en tiempo real, donde se requiere obtener datos rÃ¡pidamente.

Data warehouses o sistemas de inteligencia de negocios (BI).

Aplicaciones con muchas lecturas y pocas escrituras, donde reducir los JOINs mejora el tiempo de respuesta.

En estos casos, se acepta cierta redundancia controlada para optimizar consultas sin comprometer demasiado la consistencia.